{"version":3,"file":null,"sources":["../src/util.js","../src/createSlimReduxStore.js","../src/changeTrigger.js","../src/asyncChangeTrigger.js","../src/constants.js","../src/notifyingSelector.js","../src/calculation.js","../src/subscription.js"],"sourcesContent":["import intersection from 'lodash.intersection';\n\nexport const error = (location, msg) => {\n  throw new Error(`*** Error in ${location}: ${msg}`)\n}\n\n/*\n  Functions to determine the type of something\n  Pattern stolen from here: http://tobyho.com/2011/01/28/checking-types-in-javascript/\n*/\nexport const getType = whatever => (whatever).constructor;\nexport const isObject = obj => (obj).constructor === Object;\nexport const isArray = arr => (arr).constructor === Array;\nexport const isString = str => (str).constructor === String;\nexport const isFunction = func => typeof(func) == 'function'; // Taken from: https://jsperf.com/alternative-isfunction-implementations/4\nexport const isBoolean = binary => (binary).constructor === Boolean;\nexport const isSet = smthg => (smthg !== undefined && smthg !== null);\nexport const isEmptyString = str => (str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '') === ''); // Taken from: https://stackoverflow.com/questions/3000649/trim-spaces-from-start-and-end-of-string\nexport const isEmptyObject = obj => (Object.keys(obj).length === 0);\nexport const isSlimReduxStore = obj => (obj.slimReduxOptions);\n\n/*\n  Validates a subscription string\n*/\n\nexport const isSubscriptionStrValid = (str, state) => {\n  const subStringParts = str.split('.');\n  var statePointer = state;\n\n  // Check whether or not first part is \"store\"\n  if(subStringParts[0] !== 'state')\n    return false;\n\n  for(var i=1; i < subStringParts.length; i++){\n    const nextPart = subStringParts[i];\n\n    if(!(statePointer.hasOwnProperty(nextPart)))\n      return false;\n\n    statePointer = statePointer[nextPart];\n  }\n\n  return true;\n}\n\n/*\n  Checks whether two arrays contain any duplicates, or not\n*/\nexport const isDuplicateFree = (a, b) => (intersection(a, b).length === 0);\n","import { createStore } from 'redux';\nimport { error as _err, getType, isObject, isFunction, isBoolean } from './util';\nimport reduceReducers from 'reduce-reducers';\n\nexport function createSlimReduxStore(initialState, options) {\n  const error = msg => _err('createSlimReduxStore()', msg);\n  global.window = global;\n\n  /*\n    Set default values\n  */\n  const defaultReducer        = state => state,\n        registerChangeTrigger = () => { error(`It's not neccessary anymore to register change triggers. Please see https://github.com/aGuyNamedJonas/slim-redux/blob/master/README.md#api-reference for details.`) };\n\n  // Default values\n  var rootReducer = defaultReducer,\n      middleware  = undefined,\n      slimReduxOptions = {\n        disableActionDispatch : false,\n        disableGlobalStore    : false,\n      },\n      slimReduxChangeTriggers = {};\n\n  /*\n    Check input parameters, this puppy should be fool proof :)\n  */\n  if(arguments.length > 2)\n    error(`Only 2 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(initialState === undefined || initialState === null)\n    error(`initialState (first argument) cannot be null or undefined, got: ${initialState}`);\n\n  // Check the options argument\n  if(options !== undefined){\n    // Check whether it's an object\n    if(!isObject(options))\n      error(`options (second argument) needs to be an object. Instead got argument of type: ${getType(options)}`)\n\n    // Check option names and their values\n    const optionKeys = Object.keys(options);\n\n    for(var i=0; i<optionKeys.length; i++){\n      let name = optionKeys[i];\n      let option = options[name];\n\n      switch(name){\n        case 'rootReducer':\n          if(!isFunction(option))\n            error(`The value for the \"rootReducer\" option needs to be of Type \"Function\", got ${getType(option)}`)\n          else\n            rootReducer = options.rootReducer;\n          break;\n\n        case 'middleware':\n          if(!isFunction(option))\n            error(`The value for the \"middleware\" option needs to be of Type \"Function\", got ${getType(option)}`)\n          else\n            middleware = options.middleware;\n          break;\n\n        case 'disableActionDispatch':\n          if(!isBoolean(option))\n            error(`The value for the \"disableActionDispatch\" option needs to be of Type \"Boolean\", got ${getType(option)}`)\n          else\n            slimReduxOptions.disableActionDispatch = options.disableActionDispatch;\n          break;\n\n        case 'disableGlobalStore':\n          if(!isBoolean(option))\n            error(`The value for the \"disableGlobalStore\" option needs to be of Type \"Boolean\", got ${getType(option)}`)\n          else\n            slimReduxOptions.disableGlobalStore = options.disableGlobalStore;\n          break;\n\n        default:\n          error(`Unknown option: \"${name}\"`);\n      }\n    }\n  }\n\n  /*\n    Create the redux store, inject the slim-redux reducer and the slim-redux functionality into it\n  */\n  var store = createStore(rootReducer, initialState, middleware);\n\n  // Inject all the good stuff into the store\n  store.registerChangeTrigger   = registerChangeTrigger;\n  store.slimReduxOptions        = slimReduxOptions;\n  store.slimReduxChangeTriggers = slimReduxChangeTriggers;\n\n  /*\n    Setup internal slim-redux reducer\n  */\n  function slimReduxReducer(state, action){\n    const actionType           = action.type,\n          payload              = action.payload,\n          actionTypeRegistered = (this.slimReduxChangeTriggers[actionType] !== undefined);\n\n    if(actionTypeRegistered){\n      const reducer        = this.slimReduxChangeTriggers[actionType].reducer,\n            focusSubString = this.slimReduxChangeTriggers[actionType].focusSubString,\n            getFocusState  = this.slimReduxChangeTriggers[actionType].getFocusState,\n            setFocusState  = this.slimReduxChangeTriggers[actionType].setFocusState;\n\n      // Case #1: Focus subscription string was set --> Change trigger function only gets executed on a part of the state\n      if(focusSubString){\n        const focusState    = getFocusState(state),\n              newFocusState = reducer(...payload, focusState),\n              newState      = setFocusState(newFocusState, state);\n\n        return newState;\n      }\n\n      // Case #2: Focus subscription string null --> Execute change trigger function on complete state\n      return reducer(...payload, state);\n    } else\n      return state;\n\n  }\n\n  // Inject internal reducer\n  const enhancedRootReducer = reduceReducers(rootReducer, slimReduxReducer.bind(store));\n  store.replaceReducer(enhancedRootReducer);\n\n  // Register store instance in global namespace if not turned off\n  if(!slimReduxOptions.disableGlobalStore)\n    window.store = store;\n\n  return store;\n}\n","import { error as _err, getType, isString, isFunction, isObject, isSet, isEmptyString, isSubscriptionStrValid } from './util';\n\nexport function changeTrigger(actionType, reducer, focusSubString){\n  const error = msg => _err('changeTrigger()', msg);\n\n  /*\n    Check input parameters, make it incredibly tight against faulty use\n  */\n  if(arguments.length > 3)\n    error(`Only three arguments allowed, got ${arguments.length}: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(actionType === undefined || actionType === null || actionType.replace(/\\s/g, '') === '')\n    error(`\"actionType\" (first argument) cannot be empty, null, undefined or only contain whitespace: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isString(actionType))\n    error(`\"actionType\" (first argument) needs to be of type String, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(reducer))\n    error(`\"reducer\" (second argument) cannot be undefined or null: \\n ${JSON.stringify(arguments, null, 2)}`)\n\n  if(!isFunction(reducer))\n    error(`\"reducer\" (second argument) needs to be of type Function, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(reducer.length === 0)\n    error(`\"reducer\" (second argument) needs to have at least one argument: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(isSet(focusSubString) && !isString(focusSubString))\n    error(`\"focusSubString\" (optional third argument) needs to be a string \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(isSet(focusSubString) && isEmptyString(focusSubString))\n    error(`\"focusSubString\" (optional third argument) cannot be empty \\n ${JSON.stringify(arguments, null, 2)}`);\n\n\n  /*\n    Setup all the things the change trigger function needs inside a closure (ct = change trigger)\n  */\n  const ctActionType            = actionType,\n        ctReducerFunc           = reducer,\n        ctReducerArgumentsCount = reducer.length,   // Rename this to payload arguments count?\n        ctError                 = msg => _err(`${ctActionType} change trigger function`, msg),\n        ctFocusSubString        = focusSubString || null;\n        \n  var   ctRegistered            = false,\n        storeParam              = null;\n\n  function changeTriggerFunction(...parameters){\n    /*\n      Check parameters\n    */\n\n    // Check for the 'slimReduxOptions' key in the last argument to assess whether it's a slim-redux store\n    const lastArg = parameters[parameters.length - 1];\n\n    if(parameters.length > 0)\n      storeParam = (isObject(lastArg) && 'slimReduxOptions' in lastArg ? lastArg : null);\n    else\n      storeParam = null;\n\n    // Get store either from the parameters, the global scope (if setup) or throw an error\n    const store = storeParam || window.store;\n\n    if(!isSet(store))\n      ctError(`Cannot find slim-redux store instance in arguments (last parameter) of change trigger or in window.store (global scope, set by createSlimReduxStore()). If set the (disableGlobalStore: true) option in createSlimReduxStore(), make sure to pass in the desired slim-redux store instance as the last argument in every change trigger call`);\n\n    // If last argument is not a slim-redux store instance, max. amount of arguments can be one less than the reducer func. had\n    if(storeParam === null && parameters.length > ctReducerArgumentsCount - 1)\n      ctError(`Last argument doesn't seem to be slim-redux store instance, thus max. allowed arguments: ${ctReducerArgumentsCount - 1}, got ${parameters.length} instead: \\n ${JSON.stringify(parameters, null, 2)}`);\n\n    if(storeParam !== null && parameters.length > ctReducerArgumentsCount)\n      ctError(`Last argument seems to be slim-redux store instance, thus max. allowed arguments: ${ctReducerArgumentsCount}, got ${parameters.length} instead: \\n ${JSON.stringify(parameters, null, 2)}`);\n\n    /*\n      Register change trigger in slim-redux reducer, if not done yet\n    */\n    if(!ctRegistered){\n      // Check the subscription string of the change trigger\n      if(isSet(ctFocusSubString) && !isSubscriptionStrValid(ctFocusSubString, store.getState()))\n        ctError(`\"focusSubString\" (${ctFocusSubString}) could not be found in state \\n ${JSON.stringify(store.getState(), null, 2)}`);\n\n      store.slimReduxChangeTriggers[ctActionType] = {\n        reducer        : ctReducerFunc,      // change trigger function\n        focusSubString : ctFocusSubString,   // subscription string which dictates the focus of the change trigger function\n        getFocusState  : null,\n        setFocusState  : null,\n      };\n\n      // If change trigger has a focus string, set that up\n      if(ctFocusSubString) {\n        store.slimReduxChangeTriggers[ctActionType].getFocusState = eval(`state => ${ctFocusSubString}`),  // function which will return the part of the state that the change trigger processes\n        store.slimReduxChangeTriggers[ctActionType].setFocusState = eval(`(value, state) => { ${ctFocusSubString} = value; return state; }`) // function which will set a part of the state and return the full state\n      }\n\n      ctRegistered = true;\n    }\n\n    /*\n      Prepare action and then dispatch it\n    */\n    var payload = [];\n\n    for(var i=0; i<ctReducerArgumentsCount - 1; i++)\n      payload.push(parameters[i]);\n\n    const action = { type: ctActionType, payload };\n\n    // Dispatch action\n    store.dispatch(action);\n\n    // Return dispatched action and the new state\n    return { action, state: store.getState() };\n  }\n\n  return changeTriggerFunction;\n};\n","import { error as _err, getType, isObject, isEmptyObject, isSet, isFunction, isDuplicateFree, isSlimReduxStore } from './util';\n\nexport function asyncChangeTrigger(changeTriggers, triggerFunction) {\n  const error = msg => _err('asyncChangeTrigger()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n  if(arguments.length > 2)\n    error(`Only 2 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeTriggers\n  if(!isObject(changeTriggers))\n    error(`\"changeTriggers\" (first argument) needs to be an object, got ${getType(changeTriggers)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(changeTriggers) || isEmptyObject(changeTriggers))\n    error(`\"changeTriggers\" (first argument) cannot be null, empty, or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check triggerFunction\n  if(!isFunction(triggerFunction))\n    error(`\"triggerFunction\" (second argument) needs to be a function, got ${getType(triggerFunction)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(triggerFunction))\n    error(`\"triggerFunction\" (second argument) cannot be null or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n\n  /*\n    Implementation\n  */\n  const actError           = msg => _err(`Async change trigger function`, msg),\n        actChangeTriggers  = changeTriggers,\n        actTriggerFunction = triggerFunction;\n\n  var storeParam = null;\n\n\n  function asyncChangeTriggerFunction(...parameters){\n      if(parameters.length > 0){\n        const lastArg = parameters[parameters.length - 1];\n        storeParam = (isObject(lastArg) && isSlimReduxStore(lastArg) ? lastArg : null);\n      }\n\n      // Get store either from the parameters, the global scope (if setup) or throw an error\n      const store = storeParam || window.store;\n\n      if(!isSet(store))\n        actError(`Cannot find slim-redux store instance in arguments (last parameter) of async change trigger or in window.store (global scope, set by createSlimReduxStore()). If set the (disableGlobalStore: true) option in createSlimReduxStore(), make sure to pass in the desired slim-redux store instance as the last argument in every change trigger call`);\n\n      // Call triggerFunction w/ store instance, change triggers and the params!\n      actTriggerFunction.apply({ store, ...actChangeTriggers }, parameters);\n\n      // TODO: Adapt tests to use this.changeTrigger! Also make sure this even works :) (quick'n'dirty example)\n  }\n\n  return asyncChangeTriggerFunction;\n}\n","export const CANCEL_SUBSCRIPTION = 'CANCEL_SUBSCRIPTION';","import { createSelectorCreator } from 'reselect'\n\n/*\n    Special reselector which can tell us whether the underlying value has actually changed\n*/\nconst defaultEqualityCheck = (a, b) => (a === b);\n\nconst areArgumentsShallowlyEqual = (equalityCheck, prev, next) => {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst defaultMemoize = (func, equalityCheck = defaultEqualityCheck) => {\n  let lastArgs = null\n  let lastResult = null\n  // we reference arguments instead of spreading them for performance reasons\n  return function () {\n    let changed = false\n\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n      changed = true\n    }\n\n    lastArgs = arguments\n\n    return {\n      hasChanged: changed,\n      data: lastResult,\n    }\n  }\n}\n\nconst getNotifyingSelectorCreator = () => createSelectorCreator(defaultMemoize);\nconst createNotifyingSelector = getNotifyingSelectorCreator();\n\nexport default createNotifyingSelector;\n","import { error as _err, getType, isObject, isArray, isSet, isString, isSubscriptionStrValid, isFunction, isSlimReduxStore } from './util';\nimport { CANCEL_SUBSCRIPTION } from './constants';\nimport createNotifyingSelector from './notifyingSelector';\n\nexport function calculation(subscriptions, calcFunction, changeCallback, storeArg){\nconst error = msg => _err('calculation()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n\n  if(arguments.length > 4)\n    error(`Only four arguments allowed, got ${arguments.length}: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check subscriptions\n  if(!isArray(subscriptions))\n    error(`\"subscriptions\" (first argument) needs to be of type Array, got \\n ${getType(subscriptions)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(subscriptions) || subscriptions.length === 0)\n    error(`\"subscriptions\" (first argument) cannot be undefined, null, or empty: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check calcFunction\n  if(!isFunction(calcFunction))\n    error(`\"calcFunction\" (second argument) needs to be a function, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(calcFunction))\n    error(`\"calcFunction\" (second argument) cannot be undefined or null: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(calcFunction.length !== subscriptions.length)\n    error(`\"calcFunction\" (second argument) Needs to have as many arguments as there are subscriptions. Calculations can only rely on their subscriptions for data: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeCallback\n  if(!isSet(changeCallback))\n    error(`\"changeCallback\" (third argument) cannot be undefined or null:  \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check (optional) store instance\n  if(storeArg && !isSlimReduxStore(storeArg))\n    error(`\"storeArg\" (third argument) is optional, but has to be a slim-redux store instance if provided: \\n${JSON.stringify(arguments, null, 2)}`);\n\n  const store = storeArg || window.store;\n\n  if(!isSet(store))\n    error(`No store instance provided in global and local scope! In case you set \"disableGlobalStore\" when creating slim-redux store, make sure to pass it in as the last argument!\\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSlimReduxStore(store))\n    error(`Store instance provided is not a slim-redux store! \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // check subscription strings\n  subscriptions.map((subscription, i) => {\n    if(!isString(subscription))\n      error(`subscriptions need to be of value string, got ${getType(subscription)} for subscriptions[${i}] instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n    if(!isSubscriptionStrValid(subscription, store.getState()))\n      error(`Cannot find subscription path '${subscription}'  in state (subscriptions[${i}]). Remember: Subscription strings have to be of the form: \"state.todos.filter\". \\n ${JSON.stringify(store.getState(), null, 2)}`);\n  });\n\n\n  /*\n    Implementation\n  */\n  // Same approach as with subscriptions:\n  // #1: Turn subscriptions into functions\n  const subFunctions = subscriptions.map(subscription => {\n    // Straight up copied from the implementation of subscription()...\n    const getStateFunctionString    = `state => ${subscription}`,   // Syntax for a function: state => subscription-string part of state\n          getStateFunction          = eval(getStateFunctionString); // Turn the string from step one into an actual function\n\n    return getStateFunction;\n  })\n\n  // #2: Create notifying selector (using the subscription functions + calcFunction)\n  const checkCalculationSelector = createNotifyingSelector(\n    ...subFunctions,\n    calcFunction,\n  );\n\n  // Initial firing - initially of course the state has changed!\n  checkCalculationSelector(store.getState());\n\n  // #3: Subscribe calculation using store.subscribe() and only call changeCallback if it actually changed\n  const unsubscribe = store.subscribe(() => {\n    const subscriptionState = checkCalculationSelector(store.getState());\n\n    if(subscriptionState.hasChanged)\n      changeCallback(subscriptionState.data, store.getState());\n  });\n\n  // #4: Create the function which will be returned\n  const getCalculationOrUnsubscribe = (instruction) => {\n    if(instruction === CANCEL_SUBSCRIPTION)\n      unsubscribe();\n    else\n      return checkCalculationSelector(store.getState()).data;    // Returns the calculation value\n  }\n\n  // All done!\n  return getCalculationOrUnsubscribe;\n}\n","import { error as _err, getType, isString, isFunction, isSet, isEmptyString, isSlimReduxStore, isSubscriptionStrValid } from './util';\nimport { CANCEL_SUBSCRIPTION } from './constants';\nimport createNotifyingSelector from './notifyingSelector';\n\nexport function subscription(subscription, changeCallback, storeArg) {\n  const error = msg => _err('subscription()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n  if(arguments.length > 3)\n    error(`Only 3 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check subscription\n  if(!isString(subscription))\n    error(`\"subscription\" (first argument) needs to be a string, got ${getType(subscription)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(subscription) || isEmptyString(subscription))\n    error(`\"subscription\" (first argument) cannot be null, empty, or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeCallback\n  if(!isFunction(changeCallback))\n    error(`\"changeCallback\" (second argument) needs to be a function, got ${getType(changeCallback)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(changeCallback))\n    error(`\"changeCallback\" (second argument) cannot be null or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check (optional) store instance\n  if(storeArg && !isSlimReduxStore(storeArg))\n    error(`\"storeArg\" (third argument) is optional, but has to be a slim-redux store instance if provided: \\n${JSON.stringify(arguments, null, 2)}`);\n\n  const store = storeArg || window.store;\n\n  if(!store)\n    error(`No store instance provided in global and local scope! In case you set \"disableGlobalStore\" when creating slim-redux store, make sure to pass it in as the last argument!\\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSlimReduxStore(store))\n    error(`Store instance provided is not a slim-redux store! \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // check subscription string\n  if(!isSubscriptionStrValid(subscription, store.getState()))\n    error(`Cannot find subscription path '${subscription}'  in state. Remember: Subscription strings have to be of the form: \"state.todos.filter\". \\n ${JSON.stringify(store.getState(), null, 2)}`);\n\n  /*\n    Implementation\n  */\n\n  // Step #1: Create a notifying selector out of a function we build using the subscription string\n  const getStateFunctionString    = `state => ${subscription}`,   // Syntax for a function: state => subscription-string part of state\n        getStateFunction          = eval(getStateFunctionString), // Turn the string from step one into an actual function\n        checkSubscriptionSelector = createNotifyingSelector(      // Create subscrption selector using the function we just created\n          getStateFunction,\n          data => data,\n        );\n\n  // Initial firing - initially of course the state has changed!\n  checkSubscriptionSelector(store.getState());\n\n  // Step #2: Subscribe to state changes (native redux API function), but only trigger changeTrigger() when our subscription has changed\n  const unsubscribe = store.subscribe(() => {\n    const subscriptionState = checkSubscriptionSelector(store.getState());\n\n    if(subscriptionState.hasChanged)\n      changeCallback(subscriptionState.data, store.getState());\n  });\n\n  // Step #3: Create getter for subscription value / unsubscribe function\n  const getStateOrUnsubscribe = (instruction) => {\n    if(instruction === CANCEL_SUBSCRIPTION)\n      unsubscribe();\n    else\n      return checkSubscriptionSelector(store.getState()).data;    // Returns the subscription value\n  }\n\n  // All done!\n  return getStateOrUnsubscribe;\n}\n"],"names":["error","location","msg","Error","getType","whatever","constructor","isObject","obj","Object","isArray","arr","Array","isString","str","String","isFunction","func","isBoolean","binary","Boolean","isSet","smthg","undefined","isEmptyString","replace","isEmptyObject","length","isSlimReduxStore","slimReduxOptions","isSubscriptionStrValid","state","subStringParts","split","statePointer","i","nextPart","hasOwnProperty","createSlimReduxStore","initialState","options","_err","window","global","defaultReducer","registerChangeTrigger","rootReducer","middleware","slimReduxChangeTriggers","arguments","optionKeys","name","option","disableActionDispatch","disableGlobalStore","store","createStore","slimReduxReducer","action","actionType","type","payload","actionTypeRegistered","reducer","focusSubString","getFocusState","setFocusState","focusState","newFocusState","newState","enhancedRootReducer","reduceReducers","bind","replaceReducer","changeTrigger","ctActionType","ctReducerFunc","ctReducerArgumentsCount","ctError","ctFocusSubString","ctRegistered","storeParam","changeTriggerFunction","parameters","lastArg","getState","eval","push","dispatch","asyncChangeTrigger","changeTriggers","triggerFunction","actError","actChangeTriggers","actTriggerFunction","asyncChangeTriggerFunction","apply","CANCEL_SUBSCRIPTION","defaultEqualityCheck","a","b","areArgumentsShallowlyEqual","equalityCheck","prev","next","defaultMemoize","lastArgs","lastResult","changed","getNotifyingSelectorCreator","createSelectorCreator","createNotifyingSelector","calculation","subscriptions","calcFunction","changeCallback","storeArg","map","subscription","subFunctions","getStateFunctionString","getStateFunction","checkCalculationSelector","unsubscribe","subscribe","subscriptionState","hasChanged","data","getCalculationOrUnsubscribe","instruction","checkSubscriptionSelector","getStateOrUnsubscribe"],"mappings":";;;;;;;;;;;;;;;AAEO,IAAMA,QAAQ,SAARA,KAAQ,CAACC,QAAD,EAAWC,GAAX,EAAmB;QAChC,IAAIC,KAAJ,mBAA0BF,QAA1B,UAAuCC,GAAvC,CAAN;CADK;;;;;;AAQP,AAAO,IAAME,UAAU,SAAVA,OAAU;SAAaC,QAAD,CAAWC,WAAvB;CAAhB;AACP,AAAO,IAAMC,WAAW,SAAXA,QAAW;SAAQC,GAAD,CAAMF,WAAN,KAAsBG,MAA7B;CAAjB;AACP,AAAO,IAAMC,UAAU,SAAVA,OAAU;SAAQC,GAAD,CAAML,WAAN,KAAsBM,KAA7B;CAAhB;AACP,AAAO,IAAMC,WAAW,SAAXA,QAAW;SAAQC,GAAD,CAAMR,WAAN,KAAsBS,MAA7B;CAAjB;AACP,AAAO,IAAMC,aAAa,SAAbA,UAAa;SAAQ,OAAOC,IAAP,IAAgB,UAAxB;CAAnB;AACP,AAAO,IAAMC,YAAY,SAAZA,SAAY;SAAWC,MAAD,CAASb,WAAT,KAAyBc,OAAnC;CAAlB;AACP,AAAO,IAAMC,QAAQ,SAARA,KAAQ;SAAUC,UAAUC,SAAV,IAAuBD,UAAU,IAA3C;CAAd;AACP,AAAO,IAAME,gBAAgB,SAAhBA,aAAgB;SAAQV,IAAIW,OAAJ,CAAY,QAAZ,EAAsB,EAAtB,EAA0BA,OAA1B,CAAkC,QAAlC,EAA4C,EAA5C,MAAoD,EAA5D;CAAtB;AACP,AAAO,IAAMC,gBAAgB,SAAhBA,aAAgB;SAAQ,aAAYlB,GAAZ,EAAiBmB,MAAjB,KAA4B,CAApC;CAAtB;AACP,AAAO,IAAMC,mBAAmB,SAAnBA,gBAAmB;SAAQpB,IAAIqB,gBAAZ;CAAzB;;;;;;AAMP,AAAO,IAAMC,yBAAyB,SAAzBA,sBAAyB,CAAChB,GAAD,EAAMiB,KAAN,EAAgB;MAC9CC,iBAAiBlB,IAAImB,KAAJ,CAAU,GAAV,CAAvB;MACIC,eAAeH,KAAnB;;;MAGGC,eAAe,CAAf,MAAsB,OAAzB,EACE,OAAO,KAAP;;OAEE,IAAIG,IAAE,CAAV,EAAaA,IAAIH,eAAeL,MAAhC,EAAwCQ,GAAxC,EAA4C;QACpCC,WAAWJ,eAAeG,CAAf,CAAjB;;QAEG,CAAED,aAAaG,cAAb,CAA4BD,QAA5B,CAAL,EACE,OAAO,KAAP;;mBAEaF,aAAaE,QAAb,CAAf;;;SAGK,IAAP;CAjBK;;;;EAuBP,AAAO;;AC5CA,SAASE,oBAAT,CAA8BC,YAA9B,EAA4CC,OAA5C,EAAqD;MACpDxC,WAAQ,SAARA,QAAQ;WAAOyC,MAAK,wBAAL,EAA+BvC,GAA/B,CAAP;GAAd;SACOwC,MAAP,GAAgBC,MAAhB;;;;;MAKMC,iBAAwB,SAAxBA,cAAwB;WAASb,KAAT;GAA9B;MACMc,wBAAwB,SAAxBA,qBAAwB,GAAM;;GADpC;;;MAIIC,cAAcF,cAAlB;MACIG,aAAcxB,SADlB;MAEIM,mBAAmB;2BACO,KADP;wBAEO;GAJ9B;MAMImB,0BAA0B,EAN9B;;;;;MAWGC,UAAUtB,MAAV,GAAmB,CAAtB,EACE3B,wCAAmCiD,UAAUtB,MAA7C,mBAAiE,gBAAesB,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAjE;;MAECV,iBAAiBhB,SAAjB,IAA8BgB,iBAAiB,IAAlD,EACEvC,8EAAyEuC,YAAzE;;;MAGCC,YAAYjB,SAAf,EAAyB;;QAEpB,CAAChB,SAASiC,OAAT,CAAJ,EACExC,6FAAwFI,QAAQoC,OAAR,CAAxF;;;QAGIU,aAAa,aAAYV,OAAZ,CAAnB;;SAEI,IAAIL,IAAE,CAAV,EAAaA,IAAEe,WAAWvB,MAA1B,EAAkCQ,GAAlC,EAAsC;UAChCgB,OAAOD,WAAWf,CAAX,CAAX;UACIiB,SAASZ,QAAQW,IAAR,CAAb;;cAEOA,IAAP;aACO,aAAL;cACK,CAACnC,WAAWoC,MAAX,CAAJ,EACEpD,yFAAoFI,QAAQgD,MAAR,CAApF,EADF,KAGEN,cAAcN,QAAQM,WAAtB;;;aAGC,YAAL;cACK,CAAC9B,WAAWoC,MAAX,CAAJ,EACEpD,wFAAmFI,QAAQgD,MAAR,CAAnF,EADF,KAGEL,aAAaP,QAAQO,UAArB;;;aAGC,uBAAL;cACK,CAAC7B,UAAUkC,MAAV,CAAJ,EACEpD,kGAA6FI,QAAQgD,MAAR,CAA7F,EADF,KAGEvB,iBAAiBwB,qBAAjB,GAAyCb,QAAQa,qBAAjD;;;aAGC,oBAAL;cACK,CAACnC,UAAUkC,MAAV,CAAJ,EACEpD,+FAA0FI,QAAQgD,MAAR,CAA1F,EADF,KAGEvB,iBAAiByB,kBAAjB,GAAsCd,QAAQc,kBAA9C;;;;yCAIwBH,IAA1B;;;;;;;;MAQJI,QAAQC,kBAAYV,WAAZ,EAAyBP,YAAzB,EAAuCQ,UAAvC,CAAZ;;;QAGMF,qBAAN,GAAgCA,qBAAhC;QACMhB,gBAAN,GAAgCA,gBAAhC;QACMmB,uBAAN,GAAgCA,uBAAhC;;;;;WAKSS,gBAAT,CAA0B1B,KAA1B,EAAiC2B,MAAjC,EAAwC;QAChCC,aAAuBD,OAAOE,IAApC;QACMC,UAAuBH,OAAOG,OADpC;QAEMC,uBAAwB,KAAKd,uBAAL,CAA6BW,UAA7B,MAA6CpC,SAF3E;;QAIGuC,oBAAH,EAAwB;UAChBC,UAAiB,KAAKf,uBAAL,CAA6BW,UAA7B,EAAyCI,OAAhE;UACMC,iBAAiB,KAAKhB,uBAAL,CAA6BW,UAA7B,EAAyCK,cADhE;UAEMC,gBAAiB,KAAKjB,uBAAL,CAA6BW,UAA7B,EAAyCM,aAFhE;UAGMC,gBAAiB,KAAKlB,uBAAL,CAA6BW,UAA7B,EAAyCO,aAHhE;;;UAMGF,cAAH,EAAkB;YACVG,aAAgBF,cAAclC,KAAd,CAAtB;YACMqC,gBAAgBL,4CAAWF,OAAX,UAAoBM,UAApB,GADtB;YAEME,WAAgBH,cAAcE,aAAd,EAA6BrC,KAA7B,CAFtB;;eAIOsC,QAAP;;;;aAIKN,4CAAWF,OAAX,UAAoB9B,KAApB,GAAP;KAhBF,MAkBE,OAAOA,KAAP;;;;MAKEuC,sBAAsBC,eAAezB,WAAf,EAA4BW,iBAAiBe,IAAjB,CAAsBjB,KAAtB,CAA5B,CAA5B;QACMkB,cAAN,CAAqBH,mBAArB;;;MAGG,CAACzC,iBAAiByB,kBAArB,EACEZ,OAAOa,KAAP,GAAeA,KAAf;;SAEKA,KAAP;;;AC9HK,SAASmB,aAAT,CAAuBf,UAAvB,EAAmCI,OAAnC,EAA4CC,cAA5C,EAA2D;MAC1DhE,WAAQ,SAARA,QAAQ;WAAOyC,MAAK,iBAAL,EAAwBvC,GAAxB,CAAP;GAAd;;;;;MAKG+C,UAAUtB,MAAV,GAAmB,CAAtB,EACE3B,gDAA2CiD,UAAUtB,MAArD,aAAmE,gBAAesB,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAnE;;MAECU,eAAepC,SAAf,IAA4BoC,eAAe,IAA3C,IAAmDA,WAAWlC,OAAX,CAAmB,KAAnB,EAA0B,EAA1B,MAAkC,EAAxF,EACEzB,4GAAuG,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAvG;;MAEC,CAACpC,SAAS8C,UAAT,CAAJ,EACE3D,4EAAuEI,QAAQuD,UAAR,CAAvE,qBAA0G,gBAAeV,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA1G;;MAEC,CAAC5B,MAAM0C,OAAN,CAAJ,EACE/D,0EAAqE,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAArE;;MAEC,CAACjC,WAAW+C,OAAX,CAAJ,EACE/D,4EAAuEI,QAAQuD,UAAR,CAAvE,qBAA0G,gBAAeV,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA1G;;MAECc,QAAQpC,MAAR,KAAmB,CAAtB,EACE3B,kFAA6E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA7E;;MAEC5B,MAAM2C,cAAN,KAAyB,CAACnD,SAASmD,cAAT,CAA7B,EACEhE,iFAA4E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA5E;;MAEC5B,MAAM2C,cAAN,KAAyBxC,cAAcwC,cAAd,CAA5B,EACEhE,4EAAuE,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAvE;;;;;MAMI0B,eAA0BhB,UAAhC;MACMiB,gBAA0Bb,OADhC;MAEMc,0BAA0Bd,QAAQpC,MAFxC;;YAGgC,SAA1BmD,OAA0B;WAAOrC,MAAQkC,YAAR,+BAAgDzE,GAAhD,CAAP;GAHhC;MAIM6E,mBAA0Bf,kBAAkB,IAJlD;;MAMMgB,eAA0B,KAAhC;MACMC,aAA0B,IADhC;;WAGSC,qBAAT,GAA6C;sCAAXC,UAAW;gBAAA;;;;;;;;QAMrCC,UAAUD,WAAWA,WAAWxD,MAAX,GAAoB,CAA/B,CAAhB;;QAEGwD,WAAWxD,MAAX,GAAoB,CAAvB,EACEsD,aAAc1E,SAAS6E,OAAT,KAAqB,sBAAsBA,OAA3C,GAAqDA,OAArD,GAA+D,IAA7E,CADF,KAGEH,aAAa,IAAb;;;QAGI1B,QAAQ0B,cAAcvC,OAAOa,KAAnC;;QAEG,CAAClC,MAAMkC,KAAN,CAAJ,EACEuB;;;QAGCG,eAAe,IAAf,IAAuBE,WAAWxD,MAAX,GAAoBkD,0BAA0B,CAAxE,EACEC,wGAAoGD,0BAA0B,CAA9H,eAAwIM,WAAWxD,MAAnJ,qBAAyK,gBAAewD,UAAf,EAA2B,IAA3B,EAAiC,CAAjC,CAAzK;;QAECF,eAAe,IAAf,IAAuBE,WAAWxD,MAAX,GAAoBkD,uBAA9C,EACEC,+FAA6FD,uBAA7F,cAA6HM,WAAWxD,MAAxI,qBAA8J,gBAAewD,UAAf,EAA2B,IAA3B,EAAiC,CAAjC,CAA9J;;;;;QAKC,CAACH,YAAJ,EAAiB;;UAEZ3D,MAAM0D,gBAAN,KAA2B,CAACjD,uBAAuBiD,gBAAvB,EAAyCxB,MAAM8B,QAAN,EAAzC,CAA/B,EACEP,+BAA6BC,gBAA7B,yCAAiF,gBAAexB,MAAM8B,QAAN,EAAf,EAAiC,IAAjC,EAAuC,CAAvC,CAAjF;;YAEIrC,uBAAN,CAA8B2B,YAA9B,IAA8C;iBAC3BC,aAD2B;wBAE3BG,gBAF2B;uBAG3B,IAH2B;uBAI3B;OAJnB;;;UAQGA,gBAAH,EAAqB;cACb/B,uBAAN,CAA8B2B,YAA9B,EAA4CV,aAA5C,GAA4DqB,mBAAiBP,gBAAjB,CAA5D;cACM/B,uBAAN,CAA8B2B,YAA9B,EAA4CT,aAA5C,GAA4DoB,8BAA4BP,gBAA5B,+BAD5D,CADmB;;;qBAKN,IAAf;;;;;;QAMElB,UAAU,EAAd;;SAEI,IAAI1B,IAAE,CAAV,EAAaA,IAAE0C,0BAA0B,CAAzC,EAA4C1C,GAA5C;cACUoD,IAAR,CAAaJ,WAAWhD,CAAX,CAAb;KAEF,IAAMuB,SAAS,EAAEE,MAAMe,YAAR,EAAsBd,gBAAtB,EAAf;;;UAGM2B,QAAN,CAAe9B,MAAf;;;WAGO,EAAEA,cAAF,EAAU3B,OAAOwB,MAAM8B,QAAN,EAAjB,EAAP;;;SAGKH,qBAAP;;;AC9GK,SAASO,kBAAT,CAA4BC,cAA5B,EAA4CC,eAA5C,EAA6D;MAC5D3F,WAAQ,SAARA,QAAQ;WAAOyC,MAAK,sBAAL,EAA6BvC,GAA7B,CAAP;GAAd;;;;;MAKG+C,UAAUtB,MAAV,GAAmB,CAAtB,EACE3B,wCAAmCiD,UAAUtB,MAA7C,mBAAiE,gBAAesB,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAjE;;;MAGC,CAAC1C,SAASmF,cAAT,CAAJ,EACE1F,2EAAsEI,QAAQsF,cAAR,CAAtE,qBAA6G,gBAAezC,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA7G;;MAEC,CAAC5B,MAAMqE,cAAN,CAAD,IAA0BhE,cAAcgE,cAAd,CAA7B,EACE1F,wFAAmF,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAnF;;;MAGC,CAACjC,WAAW2E,eAAX,CAAJ,EACE3F,8EAAyEI,QAAQuF,eAAR,CAAzE,qBAAiH,gBAAe1C,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAjH;;MAEC,CAAC5B,MAAMsE,eAAN,CAAJ,EACE3F,kFAA6E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA7E;;;;;MAMI2C,WAAqB,SAArBA,QAAqB;WAAOnD,uCAAsCvC,GAAtC,CAAP;GAA3B;MACM2F,oBAAqBH,cAD3B;MAEMI,qBAAqBH,eAF3B;;MAIIV,aAAa,IAAjB;;WAGSc,0BAAT,GAAkD;sCAAXZ,UAAW;gBAAA;;;QAC3CA,WAAWxD,MAAX,GAAoB,CAAvB,EAAyB;UACjByD,UAAUD,WAAWA,WAAWxD,MAAX,GAAoB,CAA/B,CAAhB;mBACcpB,SAAS6E,OAAT,KAAqBxD,iBAAiBwD,OAAjB,CAArB,GAAiDA,OAAjD,GAA2D,IAAzE;;;;QAII7B,QAAQ0B,cAAcvC,OAAOa,KAAnC;;QAEG,CAAClC,MAAMkC,KAAN,CAAJ,EACEqC;;;uBAGiBI,KAAnB,YAA2BzC,YAA3B,IAAqCsC,iBAArC,GAA0DV,UAA1D;;;;;SAKGY,0BAAP;;;ACtDK,IAAME,sBAAsB,qBAA5B;;ACEP;;;AAGA,IAAMC,uBAAuB,SAAvBA,oBAAuB,CAACC,CAAD,EAAIC,CAAJ;SAAWD,MAAMC,CAAjB;CAA7B;;AAEA,IAAMC,6BAA6B,SAA7BA,0BAA6B,CAACC,aAAD,EAAgBC,IAAhB,EAAsBC,IAAtB,EAA+B;MAC5DD,SAAS,IAAT,IAAiBC,SAAS,IAA1B,IAAkCD,KAAK5E,MAAL,KAAgB6E,KAAK7E,MAA3D,EAAmE;WAC1D,KAAP;;;;MAIIA,SAAS4E,KAAK5E,MAApB;OACK,IAAIQ,IAAI,CAAb,EAAgBA,IAAIR,MAApB,EAA4BQ,GAA5B,EAAiC;QAC3B,CAACmE,cAAcC,KAAKpE,CAAL,CAAd,EAAuBqE,KAAKrE,CAAL,CAAvB,CAAL,EAAsC;aAC7B,KAAP;;;;SAIG,IAAP;CAbF;;AAgBA,IAAMsE,iBAAiB,SAAjBA,cAAiB,CAACxF,IAAD,EAAgD;MAAzCqF,aAAyC,uEAAzBJ,oBAAyB;;MACjEQ,WAAW,IAAf;MACIC,aAAa,IAAjB;;SAEO,YAAY;QACbC,UAAU,KAAd;;QAEI,CAACP,2BAA2BC,aAA3B,EAA0CI,QAA1C,EAAoDzD,SAApD,CAAL,EAAqE;;mBAEtDhC,KAAK+E,KAAL,CAAW,IAAX,EAAiB/C,SAAjB,CAAb;gBACU,IAAV;;;eAGSA,SAAX;;WAEO;kBACO2D,OADP;YAECD;KAFR;GAXF;CAJF;;AAsBA,IAAME,8BAA8B,SAA9BA,2BAA8B;SAAMC,+BAAsBL,cAAtB,CAAN;CAApC;AACA,IAAMM,0BAA0BF,6BAAhC,CAEA;;AC5CO,SAASG,WAAT,CAAqBC,aAArB,EAAoCC,YAApC,EAAkDC,cAAlD,EAAkEC,QAAlE,EAA2E;;;MAC5EpH,WAAQ,SAARA,QAAQ;WAAOyC,MAAK,eAAL,EAAsBvC,GAAtB,CAAP;GAAd;;;;;;MAMK+C,UAAUtB,MAAV,GAAmB,CAAtB,EACE3B,+CAA0CiD,UAAUtB,MAApD,aAAkE,gBAAesB,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAlE;;;MAGC,CAACvC,QAAQuG,aAAR,CAAJ,EACEjH,iFAA4EI,QAAQ6G,aAAR,CAA5E,qBAAkH,gBAAehE,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAlH;;MAEC,CAAC5B,MAAM4F,aAAN,CAAD,IAAyBA,cAActF,MAAd,KAAyB,CAArD,EACE3B,uFAAkF,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAlF;;;MAGC,CAACjC,WAAWkG,YAAX,CAAJ,EACElH,2EAAsEI,QAAQuD,UAAR,CAAtE,qBAAyG,gBAAeV,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAzG;;MAEC,CAAC5B,MAAM6F,YAAN,CAAJ,EACElH,+EAA0E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA1E;;MAECiE,aAAavF,MAAb,KAAwBsF,cAActF,MAAzC,EACE3B,0KAAqK,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAArK;;;MAGC,CAAC5B,MAAM8F,cAAN,CAAJ,EACEnH,iFAA4E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA5E;;;MAGCmE,YAAY,CAACxF,iBAAiBwF,QAAjB,CAAhB,EACEpH,gHAA2G,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA3G;;MAEIM,QAAQ6D,YAAY1E,OAAOa,KAAjC;;MAEG,CAAClC,MAAMkC,KAAN,CAAJ,EACEvD,yLAAoL,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAApL;;MAEC,CAACrB,iBAAiB2B,KAAjB,CAAJ,EACEvD,oEAA+D,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA/D;;;gBAGYoE,GAAd,CAAkB,UAACC,YAAD,EAAenF,CAAf,EAAqB;QAClC,CAACtB,SAASyG,YAAT,CAAJ,EACEtH,4DAAuDI,QAAQkH,YAAR,CAAvD,2BAAkGnF,CAAlG,sBAAoH,4BAA0B,IAA1B,EAAgC,CAAhC,CAApH;;QAEC,CAACL,uBAAuBwF,YAAvB,EAAqC/D,MAAM8B,QAAN,EAArC,CAAJ,EACErF,8CAAwCsH,YAAxC,oCAAkFnF,CAAlF,4FAA0K,gBAAeoB,MAAM8B,QAAN,EAAf,EAAiC,IAAjC,EAAuC,CAAvC,CAA1K;GALJ;;;;;;;MAcMkC,eAAeN,cAAcI,GAAd,CAAkB,wBAAgB;;QAE/CG,uCAAwCF,YAA9C;;uBACkChC,KAAKkC,sBAAL,CADlC,CAFqD;;WAK9CC,gBAAP;GALmB,CAArB;;;MASMC,2BAA2BX,4DAC5BQ,YAD4B,UAE/BL,YAF+B,GAAjC;;;2BAMyB3D,MAAM8B,QAAN,EAAzB;;;MAGMsC,cAAcpE,MAAMqE,SAAN,CAAgB,YAAM;QAClCC,oBAAoBH,yBAAyBnE,MAAM8B,QAAN,EAAzB,CAA1B;;QAEGwC,kBAAkBC,UAArB,EACEX,eAAeU,kBAAkBE,IAAjC,EAAuCxE,MAAM8B,QAAN,EAAvC;GAJgB,CAApB;;;MAQM2C,8BAA8B,SAA9BA,2BAA8B,CAACC,WAAD,EAAiB;QAChDA,gBAAgBhC,mBAAnB,EACE0B,cADF,KAGE,OAAOD,yBAAyBnE,MAAM8B,QAAN,EAAzB,EAA2C0C,IAAlD,CAJiD;GAArD;;;SAQOC,2BAAP;;;AC5FK,SAASV,YAAT,CAAsBA,YAAtB,EAAoCH,cAApC,EAAoDC,QAApD,EAA8D;MAC7DpH,WAAQ,SAARA,QAAQ;WAAOyC,MAAK,gBAAL,EAAuBvC,GAAvB,CAAP;GAAd;;;;;MAKG+C,UAAUtB,MAAV,GAAmB,CAAtB,EACE3B,wCAAmCiD,UAAUtB,MAA7C,mBAAiE,gBAAesB,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAjE;;;MAGC,CAACpC,SAASyG,YAAT,CAAJ,EACEtH,wEAAmEI,QAAQkH,YAAR,CAAnE,qBAAwG,gBAAerE,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAxG;;MAEC,CAAC5B,MAAMiG,YAAN,CAAD,IAAwB9F,cAAc8F,YAAd,CAA3B,EACEtH,sFAAiF,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAAjF;;;MAGC,CAACjC,WAAWmG,cAAX,CAAJ,EACEnH,6EAAwEI,QAAQ+G,cAAR,CAAxE,qBAA+G,gBAAelE,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA/G;;MAEC,CAAC5B,MAAM8F,cAAN,CAAJ,EACEnH,iFAA4E,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA5E;;;MAGCmE,YAAY,CAACxF,iBAAiBwF,QAAjB,CAAhB,EACEpH,gHAA2G,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA3G;;MAEIM,QAAQ6D,YAAY1E,OAAOa,KAAjC;;MAEG,CAACA,KAAJ,EACEvD,yLAAoL,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAApL;;MAEC,CAACrB,iBAAiB2B,KAAjB,CAAJ,EACEvD,oEAA+D,gBAAeiD,SAAf,EAA0B,IAA1B,EAAgC,CAAhC,CAA/D;;;MAGC,CAACnB,uBAAuBwF,YAAvB,EAAqC/D,MAAM8B,QAAN,EAArC,CAAJ,EACErF,8CAAwCsH,YAAxC,sGAAoJ,gBAAe/D,MAAM8B,QAAN,EAAf,EAAiC,IAAjC,EAAuC,CAAvC,CAApJ;;;;;;;MAOImC,uCAAwCF,YAA9C;;qBACkChC,KAAKkC,sBAAL,CADlC;;8BAEkCT;kBAAA,EAE1B;WAAQgB,IAAR;GAF0B,CAFlC;;;4BAQ0BxE,MAAM8B,QAAN,EAA1B;;;MAGMsC,cAAcpE,MAAMqE,SAAN,CAAgB,YAAM;QAClCC,oBAAoBK,0BAA0B3E,MAAM8B,QAAN,EAA1B,CAA1B;;QAEGwC,kBAAkBC,UAArB,EACEX,eAAeU,kBAAkBE,IAAjC,EAAuCxE,MAAM8B,QAAN,EAAvC;GAJgB,CAApB;;;MAQM8C,wBAAwB,SAAxBA,qBAAwB,CAACF,WAAD,EAAiB;QAC1CA,gBAAgBhC,mBAAnB,EACE0B,cADF,KAGE,OAAOO,0BAA0B3E,MAAM8B,QAAN,EAA1B,EAA4C0C,IAAnD,CAJ2C;GAA/C;;;SAQOI,qBAAP;;;;;;;;"}