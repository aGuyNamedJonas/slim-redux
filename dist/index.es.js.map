{"version":3,"file":null,"sources":["../src/util.js","../src/createSlimReduxStore.js","../src/changeTrigger.js","../src/asyncChangeTrigger.js","../src/constants.js","../src/notifyingSelector.js","../src/calculation.js","../src/subscription.js"],"sourcesContent":["import intersection from 'lodash.intersection';\n\nexport const error = (location, msg) => {\n  throw new Error(`*** Error in ${location}: ${msg}`)\n}\n\n/*\n  Functions to determine the type of something\n  Pattern stolen from here: http://tobyho.com/2011/01/28/checking-types-in-javascript/\n*/\nexport const getType = whatever => (whatever).constructor;\nexport const isObject = obj => (obj).constructor === Object;\nexport const isArray = arr => (arr).constructor === Array;\nexport const isString = str => (str).constructor === String;\nexport const isFunction = func => typeof(func) == 'function'; // Taken from: https://jsperf.com/alternative-isfunction-implementations/4\nexport const isBoolean = binary => (binary).constructor === Boolean;\nexport const isSet = smthg => (smthg !== undefined && smthg !== null);\nexport const isEmptyString = str => (str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '') === ''); // Taken from: https://stackoverflow.com/questions/3000649/trim-spaces-from-start-and-end-of-string\nexport const isEmptyObject = obj => (Object.keys(obj).length === 0);\nexport const isSlimReduxStore = obj => (obj.slimReduxOptions);\n\n/*\n  Validates a subscription string\n*/\n\nexport const isSubscriptionStrValid = (str, state) => {\n  const subStringParts = str.split('.');\n  var statePointer = state;\n\n  // Check whether or not first part is \"store\"\n  if(subStringParts[0] !== 'state')\n    return false;\n\n  for(var i=1; i < subStringParts.length; i++){\n    const nextPart = subStringParts[i];\n\n    if(!(statePointer.hasOwnProperty(nextPart)))\n      return false;\n\n    statePointer = statePointer[nextPart];\n  }\n\n  return true;\n}\n\n/*\n  Checks whether two arrays contain any duplicates, or not\n*/\nexport const isDuplicateFree = (a, b) => (intersection(a, b).length === 0);\n","import { createStore } from 'redux';\nimport { error as _err, getType, isObject, isFunction, isBoolean } from './util';\nimport reduceReducers from 'reduce-reducers';\n\nexport function createSlimReduxStore(initialState, options) {\n  const error = msg => _err('createSlimReduxStore()', msg);\n  global.window = global;\n\n  /*\n    Set default values\n  */\n  const defaultReducer        = state => state,\n        registerChangeTrigger = () => { error(`It's not neccessary anymore to register change triggers. Please see https://github.com/aGuyNamedJonas/slim-redux/blob/master/README.md#api-reference for details.`) };\n\n  // Default values\n  var rootReducer = defaultReducer,\n      middleware  = undefined,\n      slimReduxOptions = {\n        disableActionDispatch : false,\n        disableGlobalStore    : false,\n      },\n      slimReduxChangeTriggers = {};\n\n  /*\n    Check input parameters, this puppy should be fool proof :)\n  */\n  if(arguments.length > 2)\n    error(`Only 2 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(initialState === undefined || initialState === null)\n    error(`initialState (first argument) cannot be null or undefined, got: ${initialState}`);\n\n  // Check the options argument\n  if(options !== undefined){\n    // Check whether it's an object\n    if(!isObject(options))\n      error(`options (second argument) needs to be an object. Instead got argument of type: ${getType(options)}`)\n\n    // Check option names and their values\n    const optionKeys = Object.keys(options);\n\n    for(var i=0; i<optionKeys.length; i++){\n      let name = optionKeys[i];\n      let option = options[name];\n\n      switch(name){\n        case 'rootReducer':\n          if(!isFunction(option))\n            error(`The value for the \"rootReducer\" option needs to be of Type \"Function\", got ${getType(option)}`)\n          else\n            rootReducer = options.rootReducer;\n          break;\n\n        case 'middleware':\n          if(!isFunction(option))\n            error(`The value for the \"middleware\" option needs to be of Type \"Function\", got ${getType(option)}`)\n          else\n            middleware = options.middleware;\n          break;\n\n        case 'disableActionDispatch':\n          if(!isBoolean(option))\n            error(`The value for the \"disableActionDispatch\" option needs to be of Type \"Boolean\", got ${getType(option)}`)\n          else\n            slimReduxOptions.disableActionDispatch = options.disableActionDispatch;\n          break;\n\n        case 'disableGlobalStore':\n          if(!isBoolean(option))\n            error(`The value for the \"disableGlobalStore\" option needs to be of Type \"Boolean\", got ${getType(option)}`)\n          else\n            slimReduxOptions.disableGlobalStore = options.disableGlobalStore;\n          break;\n\n        default:\n          error(`Unknown option: \"${name}\"`);\n      }\n    }\n  }\n\n  /*\n    Create the redux store, inject the slim-redux reducer and the slim-redux functionality into it\n  */\n  var store = createStore(rootReducer, initialState, middleware);\n\n  // Inject all the good stuff into the store\n  store.registerChangeTrigger   = registerChangeTrigger;\n  store.slimReduxOptions        = slimReduxOptions;\n  store.slimReduxChangeTriggers = slimReduxChangeTriggers;\n\n  /*\n    Setup internal slim-redux reducer\n  */\n  function slimReduxReducer(state, action){\n    const actionType           = action.type,\n          payload              = action.payload,\n          actionTypeRegistered = (this.slimReduxChangeTriggers[actionType] !== undefined);\n\n    if(actionTypeRegistered){\n      const reducer        = this.slimReduxChangeTriggers[actionType].reducer,\n            focusSubString = this.slimReduxChangeTriggers[actionType].focusSubString,\n            getFocusState  = this.slimReduxChangeTriggers[actionType].getFocusState,\n            setFocusState  = this.slimReduxChangeTriggers[actionType].setFocusState;\n\n      // Case #1: Focus subscription string was set --> Change trigger function only gets executed on a part of the state\n      if(focusSubString){\n        const stateClone    = { ...state },   // It's vital that we don't mutate the existing state, see this: https://egghead.io/lessons/javascript-redux-avoiding-object-mutations-with-object-assign-and-spread\n              focusState    = getFocusState(stateClone),\n              newFocusState = reducer(...payload, focusState),\n              newState      = setFocusState(newFocusState, stateClone);\n\n        return newState;\n      }\n\n      // Case #2: Focus subscription string null --> Execute change trigger function on complete state\n      return reducer(...payload, state);\n    } else {\n      return state;\n    }\n\n  }\n\n  // Inject internal reducer\n  const enhancedRootReducer = reduceReducers(rootReducer, slimReduxReducer.bind(store));\n  store.replaceReducer(enhancedRootReducer);\n\n  // Register store instance in global namespace if not turned off\n  if(!slimReduxOptions.disableGlobalStore)\n    window.store = store;\n\n  return store;\n}\n","import { error as _err, getType, isString, isFunction, isObject, isSet, isEmptyString, isSubscriptionStrValid } from './util';\n\nexport function changeTrigger(actionType, reducer, focusSubString){\n  const error = msg => _err('changeTrigger()', msg);\n\n  /*\n    Check input parameters, make it incredibly tight against faulty use\n  */\n  if(arguments.length > 3)\n    error(`Only three arguments allowed, got ${arguments.length}: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(actionType === undefined || actionType === null || actionType.replace(/\\s/g, '') === '')\n    error(`\"actionType\" (first argument) cannot be empty, null, undefined or only contain whitespace: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isString(actionType))\n    error(`\"actionType\" (first argument) needs to be of type String, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(reducer))\n    error(`\"reducer\" (second argument) cannot be undefined or null: \\n ${JSON.stringify(arguments, null, 2)}`)\n\n  if(!isFunction(reducer))\n    error(`\"reducer\" (second argument) needs to be of type Function, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(reducer.length === 0)\n    error(`\"reducer\" (second argument) needs to have at least one argument: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(isSet(focusSubString) && !isString(focusSubString))\n    error(`\"focusSubString\" (optional third argument) needs to be a string \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(isSet(focusSubString) && isEmptyString(focusSubString))\n    error(`\"focusSubString\" (optional third argument) cannot be empty \\n ${JSON.stringify(arguments, null, 2)}`);\n\n\n  /*\n    Setup all the things the change trigger function needs inside a closure (ct = change trigger)\n  */\n  const ctActionType            = actionType,\n        ctReducerFunc           = reducer,\n        ctReducerArgumentsCount = reducer.length,   // Rename this to payload arguments count?\n        ctError                 = msg => _err(`${ctActionType} change trigger function`, msg),\n        ctFocusSubString        = focusSubString || null;\n        \n  var   ctRegistered            = false,\n        storeParam              = null;\n\n  function changeTriggerFunction(...parameters){\n    /*\n      Check parameters\n    */\n\n    // Check for the 'slimReduxOptions' key in the last argument to assess whether it's a slim-redux store\n    const lastArg = parameters[parameters.length - 1];\n\n    if(parameters.length > 0)\n      storeParam = (isObject(lastArg) && 'slimReduxOptions' in lastArg ? lastArg : null);\n    else\n      storeParam = null;\n\n    // Get store either from the parameters, the global scope (if setup) or throw an error\n    const store = storeParam || window.store;\n\n    if(!isSet(store))\n      ctError(`Cannot find slim-redux store instance in arguments (last parameter) of change trigger or in window.store (global scope, set by createSlimReduxStore()). If set the (disableGlobalStore: true) option in createSlimReduxStore(), make sure to pass in the desired slim-redux store instance as the last argument in every change trigger call`);\n\n    // If last argument is not a slim-redux store instance, max. amount of arguments can be one less than the reducer func. had\n    if(storeParam === null && parameters.length > ctReducerArgumentsCount - 1)\n      ctError(`Last argument doesn't seem to be slim-redux store instance, thus max. allowed arguments: ${ctReducerArgumentsCount - 1}, got ${parameters.length} instead: \\n ${JSON.stringify(parameters, null, 2)}`);\n\n    if(storeParam !== null && parameters.length > ctReducerArgumentsCount)\n      ctError(`Last argument seems to be slim-redux store instance, thus max. allowed arguments: ${ctReducerArgumentsCount}, got ${parameters.length} instead: \\n ${JSON.stringify(parameters, null, 2)}`);\n\n    /*\n      Register change trigger in slim-redux reducer, if not done yet\n    */\n    if(!ctRegistered){\n      // Check the subscription string of the change trigger\n      if(isSet(ctFocusSubString) && !isSubscriptionStrValid(ctFocusSubString, store.getState()))\n        ctError(`\"focusSubString\" (${ctFocusSubString}) could not be found in state \\n ${JSON.stringify(store.getState(), null, 2)}`);\n\n      store.slimReduxChangeTriggers[ctActionType] = {\n        reducer        : ctReducerFunc,      // change trigger function\n        focusSubString : ctFocusSubString,   // subscription string which dictates the focus of the change trigger function\n        getFocusState  : null,\n        setFocusState  : null,\n      };\n\n      // If change trigger has a focus string, set that up\n      if(ctFocusSubString) {\n        store.slimReduxChangeTriggers[ctActionType].getFocusState = eval(`state => ${ctFocusSubString}`),  // function which will return the part of the state that the change trigger processes\n        store.slimReduxChangeTriggers[ctActionType].setFocusState = eval(`(value, state) => { ${ctFocusSubString} = value; return state; }`) // function which will set a part of the state and return the full state\n      }\n\n      ctRegistered = true;\n    }\n\n    /*\n      Prepare action and then dispatch it\n    */\n    var payload = [];\n\n    for(var i=0; i<ctReducerArgumentsCount - 1; i++)\n      payload.push(parameters[i]);\n\n    const action = { type: ctActionType, payload };\n\n    // Dispatch action\n    store.dispatch(action);\n\n    // Return dispatched action and the new state\n    return { action, state: store.getState() };\n  }\n\n  return changeTriggerFunction;\n};\n","import { error as _err, getType, isObject, isEmptyObject, isSet, isFunction, isDuplicateFree, isSlimReduxStore } from './util';\n\nexport function asyncChangeTrigger(changeTriggers, triggerFunction) {\n  const error = msg => _err('asyncChangeTrigger()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n  if(arguments.length > 2)\n    error(`Only 2 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeTriggers\n  if(!isObject(changeTriggers))\n    error(`\"changeTriggers\" (first argument) needs to be an object, got ${getType(changeTriggers)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(changeTriggers) || isEmptyObject(changeTriggers))\n    error(`\"changeTriggers\" (first argument) cannot be null, empty, or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check triggerFunction\n  if(!isFunction(triggerFunction))\n    error(`\"triggerFunction\" (second argument) needs to be a function, got ${getType(triggerFunction)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(triggerFunction))\n    error(`\"triggerFunction\" (second argument) cannot be null or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(triggerFunction.length === 0)\n    error(`\"triggerFunction\" (second argument) needs to have at least one argument. The last argument is used to pass in the change triggers and the state: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  /*\n    Implementation\n  */\n  const actError           = msg => _err(`Async change trigger function`, msg),\n        actChangeTriggers  = changeTriggers,\n        actTriggerFunction = triggerFunction;\n\n  var storeParam = null;\n\n\n  function asyncChangeTriggerFunction(...parameters){\n      if(parameters.length > 0){\n        const lastArg = parameters[parameters.length - 1];\n        storeParam = (isObject(lastArg) && isSlimReduxStore(lastArg) ? lastArg : null);\n      }\n\n      // Get store either from the parameters, the global scope (if setup) or throw an error\n      const store = storeParam || window.store;\n\n      if(!isSet(store))\n        actError(`Cannot find slim-redux store instance in arguments (last parameter) of async change trigger or in window.store (global scope, set by createSlimReduxStore()). If set the (disableGlobalStore: true) option in createSlimReduxStore(), make sure to pass in the desired slim-redux store instance as the last argument in every change trigger call`);\n\n      if((storeParam && parameters.length - 1 > actTriggerFunction.length - 1) || ((!storeParam && parameters.length > actTriggerFunction.length - 1)))\n        actError(`This async change trigger function only takes ${actTriggerFunction.length - 1} arguments (not taking the last argument into account which is used to pass in change triggers + state). Not taking the optional last store argument into account, you passed in ${(storeParam ? arguments.length - 1 : arguments.length)} parameters.`);\n\n      // Wrap change triggers in a way that they use the store instance we just got hold of\n      const localStoreChangeTriggers = {...actChangeTriggers};\n      \n      // Wrap all change triggers in functions which use the store instance\n      Object.keys(actChangeTriggers).map(key => {\n        localStoreChangeTriggers[key] = function(...params){\n          // Creating a new closure to preserve the store instance\n          const ct = actChangeTriggers[key];\n\n          // We only pass down the parameters to the change trigger if the change trigger accepts any\n          if(ct.length === 1)\n            ct(store);\n          else\n            ct(...params, store);\n        }\n      });\n\n      // Call triggerFunction w/ parameters and object with state and change triggers as last argument\n      if((storeParam && parameters.length === 1) || (!storeParam && parameters.length === 0))         // in this case the async change trigger doesn't have any function arguments of its own\n        actTriggerFunction({ state: store.getState(), ...localStoreChangeTriggers });\n      else\n        actTriggerFunction(...parameters, { state: store.getState(), ...localStoreChangeTriggers });\n  }\n\n  return asyncChangeTriggerFunction;\n}\n","export const CANCEL_SUBSCRIPTION = 'CANCEL_SUBSCRIPTION';","import { createSelectorCreator } from 'reselect'\n\n/*\n    Special reselector which can tell us whether the underlying value has actually changed\n*/\nconst defaultEqualityCheck = (a, b) => (a === b);\n\nconst areArgumentsShallowlyEqual = (equalityCheck, prev, next) => {\n  if (prev === null || next === null || prev.length !== next.length) {\n    return false\n  }\n\n  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n  const length = prev.length\n  for (let i = 0; i < length; i++) {\n    if (!equalityCheck(prev[i], next[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst defaultMemoize = (func, equalityCheck = defaultEqualityCheck) => {\n  let lastArgs = null\n  let lastResult = null\n  // we reference arguments instead of spreading them for performance reasons\n  return function () {\n    let changed = false\n\n    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {\n      // apply arguments instead of spreading for performance.\n      lastResult = func.apply(null, arguments);\n      changed = true\n    }\n\n    lastArgs = arguments\n\n    return {\n      hasChanged: changed,\n      data: lastResult,\n    }\n  }\n}\n\nconst getNotifyingSelectorCreator = () => createSelectorCreator(defaultMemoize);\nconst createNotifyingSelector = getNotifyingSelectorCreator();\n\nexport default createNotifyingSelector;\n","import { error as _err, getType, isObject, isArray, isSet, isString, isSubscriptionStrValid, isFunction, isSlimReduxStore } from './util';\nimport { CANCEL_SUBSCRIPTION } from './constants';\nimport createNotifyingSelector from './notifyingSelector';\n\nexport function calculation(subscriptions, calcFunction, changeCallback, storeArg){\nconst error = msg => _err('calculation()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n\n  if(arguments.length > 4)\n    error(`Only four arguments allowed, got ${arguments.length}: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check subscriptions\n  if(!isArray(subscriptions))\n    error(`\"subscriptions\" (first argument) needs to be of type Array, got \\n ${getType(subscriptions)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(subscriptions) || subscriptions.length === 0)\n    error(`\"subscriptions\" (first argument) cannot be undefined, null, or empty: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check calcFunction\n  if(!isFunction(calcFunction))\n    error(`\"calcFunction\" (second argument) needs to be a function, got ${getType(actionType)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(calcFunction))\n    error(`\"calcFunction\" (second argument) cannot be undefined or null: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(calcFunction.length !== subscriptions.length)\n    error(`\"calcFunction\" (second argument) Needs to have as many arguments as there are subscriptions. Calculations can only rely on their subscriptions for data: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeCallback\n  if(!isSet(changeCallback))\n    error(`\"changeCallback\" (third argument) cannot be undefined or null:  \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check (optional) store instance\n  if(storeArg && !isSlimReduxStore(storeArg))\n    error(`\"storeArg\" (third argument) is optional, but has to be a slim-redux store instance if provided: \\n${JSON.stringify(arguments, null, 2)}`);\n\n  const store = storeArg || window.store;\n\n  if(!isSet(store))\n    error(`No store instance provided in global and local scope! In case you set \"disableGlobalStore\" when creating slim-redux store, make sure to pass it in as the last argument!\\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSlimReduxStore(store))\n    error(`Store instance provided is not a slim-redux store! \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // check subscription strings\n  subscriptions.map((subscription, i) => {\n    if(!isString(subscription))\n      error(`subscriptions need to be of value string, got ${getType(subscription)} for subscriptions[${i}] instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n    if(!isSubscriptionStrValid(subscription, store.getState()))\n      error(`Cannot find subscription path '${subscription}'  in state (subscriptions[${i}]). Remember: Subscription strings have to be of the form: \"state.todos.filter\". \\n ${JSON.stringify(store.getState(), null, 2)}`);\n  });\n\n\n  /*\n    Implementation\n  */\n  // Same approach as with subscriptions:\n  // #1: Turn subscriptions into functions\n  const subFunctions = subscriptions.map(subscription => {\n    // Straight up copied from the implementation of subscription()...\n    const getStateFunctionString    = `state => ${subscription}`,   // Syntax for a function: state => subscription-string part of state\n          getStateFunction          = eval(getStateFunctionString); // Turn the string from step one into an actual function\n\n    return getStateFunction;\n  })\n\n  // #2: Create notifying selector (using the subscription functions + calcFunction)\n  const checkCalculationSelector = createNotifyingSelector(\n    ...subFunctions,\n    calcFunction,\n  );\n\n  // Initial firing - initially of course the state has changed!\n  checkCalculationSelector(store.getState());\n\n  // #3: Subscribe calculation using store.subscribe() and only call changeCallback if it actually changed\n  const unsubscribe = store.subscribe(() => {\n    const subscriptionState = checkCalculationSelector(store.getState());\n\n    if(subscriptionState.hasChanged)\n      changeCallback(subscriptionState.data, store.getState());\n  });\n\n  // #4: Create the function which will be returned\n  const getCalculationOrUnsubscribe = (instruction) => {\n    if(instruction === CANCEL_SUBSCRIPTION)\n      unsubscribe();\n    else\n      return checkCalculationSelector(store.getState()).data;    // Returns the calculation value\n  }\n\n  // All done!\n  return getCalculationOrUnsubscribe;\n}\n","import { error as _err, getType, isString, isFunction, isSet, isEmptyString, isSlimReduxStore, isSubscriptionStrValid } from './util';\nimport { CANCEL_SUBSCRIPTION } from './constants';\nimport createNotifyingSelector from './notifyingSelector';\n\nexport function subscription(subscription, changeCallback, storeArg) {\n  const error = msg => _err('subscription()', msg);\n\n  /*\n    Parameter validation (see tests)\n  */\n  if(arguments.length > 3)\n    error(`Only 3 arguments allowed, ${arguments.length} given: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check subscription\n  if(!isString(subscription))\n    error(`\"subscription\" (first argument) needs to be a string, got ${getType(subscription)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(subscription) || isEmptyString(subscription))\n    error(`\"subscription\" (first argument) cannot be null, empty, or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check changeCallback\n  if(!isFunction(changeCallback))\n    error(`\"changeCallback\" (second argument) needs to be a function, got ${getType(changeCallback)} instead: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSet(changeCallback))\n    error(`\"changeCallback\" (second argument) cannot be null or undefined: \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // Check (optional) store instance\n  if(storeArg && !isSlimReduxStore(storeArg))\n    error(`\"storeArg\" (third argument) is optional, but has to be a slim-redux store instance if provided: \\n${JSON.stringify(arguments, null, 2)}`);\n\n  const store = storeArg || window.store;\n\n  if(!store)\n    error(`No store instance provided in global and local scope! In case you set \"disableGlobalStore\" when creating slim-redux store, make sure to pass it in as the last argument!\\n ${JSON.stringify(arguments, null, 2)}`);\n\n  if(!isSlimReduxStore(store))\n    error(`Store instance provided is not a slim-redux store! \\n ${JSON.stringify(arguments, null, 2)}`);\n\n  // check subscription string\n  if(!isSubscriptionStrValid(subscription, store.getState()))\n    error(`Cannot find subscription path '${subscription}'  in state. Remember: Subscription strings have to be of the form: \"state.todos.filter\". \\n ${JSON.stringify(store.getState(), null, 2)}`);\n\n  /*\n    Implementation\n  */\n\n  // Step #1: Create a notifying selector out of a function we build using the subscription string\n  const getStateFunctionString    = `state => ${subscription}`,   // Syntax for a function: state => subscription-string part of state\n        getStateFunction          = eval(getStateFunctionString), // Turn the string from step one into an actual function\n        checkSubscriptionSelector = createNotifyingSelector(      // Create subscrption selector using the function we just created\n          getStateFunction,\n          data => data,\n        );\n\n  // Initial firing - initially of course the state has changed!\n  checkSubscriptionSelector(store.getState());\n\n  // Step #2: Subscribe to state changes (native redux API function), but only trigger changeTrigger() when our subscription has changed\n  const unsubscribe = store.subscribe(() => {\n    const subscriptionState = checkSubscriptionSelector(store.getState());\n\n    if(subscriptionState.hasChanged)\n      changeCallback(subscriptionState.data, store.getState());\n  });\n\n  // Step #3: Create getter for subscription value / unsubscribe function\n  const getStateOrUnsubscribe = (instruction) => {\n    if(instruction === CANCEL_SUBSCRIPTION)\n      unsubscribe();\n    else\n      return checkSubscriptionSelector(store.getState()).data;    // Returns the subscription value\n  }\n\n  // All done!\n  return getStateOrUnsubscribe;\n}\n"],"names":["error","location","msg","Error","getType","whatever","constructor","isObject","obj","Object","isArray","arr","Array","isString","str","String","isFunction","func","isBoolean","binary","Boolean","isSet","smthg","undefined","isEmptyString","replace","isEmptyObject","length","isSlimReduxStore","slimReduxOptions","isSubscriptionStrValid","state","subStringParts","split","statePointer","i","nextPart","hasOwnProperty","createSlimReduxStore","initialState","options","_err","window","global","defaultReducer","registerChangeTrigger","rootReducer","middleware","slimReduxChangeTriggers","arguments","optionKeys","name","option","disableActionDispatch","disableGlobalStore","store","createStore","slimReduxReducer","action","actionType","type","payload","actionTypeRegistered","reducer","focusSubString","getFocusState","setFocusState","stateClone","newFocusState","focusState","newState","enhancedRootReducer","reduceReducers","bind","replaceReducer","changeTrigger","ctActionType","ctReducerFunc","ctReducerArgumentsCount","ctError","ctFocusSubString","ctRegistered","storeParam","changeTriggerFunction","parameters","lastArg","getState","eval","push","dispatch","asyncChangeTrigger","changeTriggers","triggerFunction","actError","actChangeTriggers","actTriggerFunction","asyncChangeTriggerFunction","localStoreChangeTriggers","map","key","ct","params","CANCEL_SUBSCRIPTION","defaultEqualityCheck","a","b","areArgumentsShallowlyEqual","equalityCheck","prev","next","defaultMemoize","lastArgs","lastResult","changed","apply","getNotifyingSelectorCreator","createSelectorCreator","createNotifyingSelector","calculation","subscriptions","calcFunction","changeCallback","storeArg","subscription","subFunctions","getStateFunctionString","getStateFunction","checkCalculationSelector","unsubscribe","subscribe","subscriptionState","hasChanged","data","getCalculationOrUnsubscribe","instruction","checkSubscriptionSelector","getStateOrUnsubscribe"],"mappings":"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"}